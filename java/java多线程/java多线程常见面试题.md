# java多线程常见面试题

## 多线程的优势

- 利用多核CPU

- 方便业务拆分，提升应用性能

## 并发和并行

- 并发：多个任务在同一个 CPU 核上，按细分的时间片轮流(交替)执行，从逻辑上来看那些任务是
同时执行

- 并行：单位时间内，多个处理器或多核处理器同时处理多个任务，是真正意义上的“同时进行”

## 什么是死锁？

线程死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的一种互相等待的现象。若无外
力作用，它们都将无法推进下去

### 死锁产生的必要条件

- 互斥：一个资源每次只能被一个线程使用

- 请求与保持：一个线程因请求资源而阻塞时，不释放获得的资源

- 不剥夺：线程已获得的资源，在未使用之前，不能强行剥夺

- 循环等待：线程之间循环等待着资源

### 如何避免死锁？

- 按顺序获取锁

- 设置超时时间

- 使用trylock

## callable和Future

- Callable 接口类似于 Runnable，会返回结果，且可以抛出返回结果的异常

- Future保存异步计算的结果

- Future表示一个异步计算的任务

## 线程调度模式

- 分时调度模型

- 抢占式调度模型

## 什么时候会让出线程

- 线程体中调用了 yield 方法让出了对 cpu 的占用权利

- 线程体中调用了 sleep 方法使线程进入睡眠状态

- 线程由于 IO 操作受到阻塞

- 另外一个更高优先级线程出现

- 在支持时间片的系统中，该线程的时间片用完

## sleep和wait有何区别？

- 类的不同：sleep() 是 Thread线程类的静态方法，wait() 是 Object类的方法。

- 是否释放锁：sleep() 不释放锁；wait() 释放锁。

- 用途不同：Wait 通常被用于线程间交互/通信，sleep 通常被用于暂停执行。

- 用法不同：wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify()
或者 notifyAll() 方法。sleep() 方法执行完成后，线程会自动苏醒。或者可以使用wait(long
timeout)超时后线程会自动苏醒。

## 