# 深入理解java虚拟机

## 前言

常用的jvm调优参数如下：

- -Xss: Thread stack size（线程栈容量）

- -Xms: initial heap size 初始堆大小，它指定Java虚拟机在启动时分配给堆的初始内存大小

- -Xmx: Maximum heap size 最大堆大小，它指定Java虚拟机堆的最大内存大小。

- -XX: +HeapDumpOnOutOfMemoryError 可以让虚拟机在出现内存溢出时dump当前内存快照

- -XX: +PrintGCDetails 在发生垃圾收集行为时打印内存回收日志 

- -XX：PretenureSizeThreshold参数，大于该值的对象直接在老年代

- -XX: MaxTenuringThreshold 设置晋升老年代的年龄阈值。


## 第二章 java内存区域与内存溢出异常

### 2.1 运行时数据区域

1. java虚拟机所管理的内存包含运行时区域如下：

- 线程共享区：

    - 方法区

    - 堆

- 线程隔离区

    - 虚拟机栈：描述java方法执行的线程内存模型。

        - 每个方法执行，虚拟机会创建一个栈帧，存储：**局部变量表，操作数栈，动态连接，方法出口**。方法从调用到执行完毕，对应栈帧的入栈和出栈。

    - 本地方法栈

    - 程序计数器：当前线程所执行的字节码的行号指示器，用来表示下一条需要执行的字节码指令。

        - 执行java方法：计数器记录虚拟机字节码指令的地址

        - 执行Native方法：计数器为空

        - 唯一不会存在OOM的区域

2. java虚拟机栈

- java虚拟机栈的用途是什么？
  
    描述java方法执行的内存模型。每一个方法对应一个栈帧，站帧内容包括：局部变量表、 操作数栈、 动态连接、 方法出口等信息。

    - 局部变量表

        - 局部变量表存储哪些内容？

            局部变量表存储编译期可知基本数据类型、对象引用和返回地址类型

        - 局部变量表如何存储？

            局部变量表使用局部变量槽存储数据，局部变量槽的长度为32位。
            
        - 局部变量表的大小如何确定？

            当程序编译完成，进入方法时，该方法中的局部变量完全已知，因此局部变量表的大小完全确定

    - 如果请求栈深度超过虚拟机允许的深度，则将抛出StackOverflowError

    - 如果虚拟机栈容量可以动态扩展，扩展时无法申请到足够的内存，则会抛出OOM错误

- java虚拟机栈的生命周期是什么？

    和线程相同

- java虚拟机栈可能抛出的异常类型？

    - 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverFlowError异常。

    - 如果虚拟机栈允许动态扩展，但扩展时无法申请到足够的内存时，抛出OOM异常

3. 本地方法栈

- 什么是本地方法栈？

本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native）方法服务。

- 本地方法栈可以抛出哪些异常？

本地方法栈也会在栈深度溢出或者栈扩展失败时分别抛出StackOverflowError和OutOfMemoryError异常。

- 本地方法栈的生命周期？

    和线程相同

4. java堆

- java堆的用途？

    java堆被所有的线程共享，用于存放对象实例。

- java堆是垃圾收集器管理的内存区域

- 什么是TLAB（Thread Local Allocation Buffer）？

    - 所有线程共享的堆可以划分出多个线程私有的分配缓冲区，提升对象的分配效率。

    - 但是无论如何划分，堆仍然是所有线程共享，用于存放对象实例。

- 如果设置扩展堆的大小？

    通过参数-Xmx和-Xms设定。其中-Xmx表示最大堆大小，-Xms表示初始化堆大小。

    - 通常将-Xms（初始堆大小）和-Xmx（最大堆大小）设定相同的原因是什么？

        - 避免程序在运行过程中频繁调整堆的大小，这个过程存在一定的开销：需要GC和对象迁移。

        - 一致性的堆大小更容易检测和诊断内存泄漏情况。

- java堆中会抛出什么异常？

如果没有足够的内存为对象分配空间，并且java堆也无法扩展时，抛出OOM异常

5. 方法区（别名非堆，Non-Heap）

- 方法区的作用是什么？

    方法区是各个线程共享的内存区域，用于存储类的结构信息、静态变量信息、常量、类方法等数据。


- 什么是运行时常量池？

    Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表（Constant Pool Table），用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。常量池的作用包括：

    - 存储字符串常量：包括在代码中直接出现的字符串，以及由String类创建的字符串对象。

    - 存储基本数据类型的常量：例如整数、浮点数等。

    - 存储符号引用：包括类和接口的全限定名、字段的名称和描述符、方法的名称和描述符等。

- 方法区可以抛出哪些异常？

    方法区无法满足新的内存分配需求时，将抛出OutOfMemoryError异常。

    - 类太多，造成方法区无法容纳类的元数据

    - 大量的字符串常量，存储在运行时常量池中

    - 大量的静态变量和常量

    - 动态代理类

- 运行时常量池的作用是什么？

    运行时常量池用于存放编译期生成的各种字面量和符号引用

    - 字面量：字符串，常数

    - 符号引用：对类，字段，方法的引用（变量名，字段名）

6. 直接内存

- 什么是直接内存？

直接内存（Direct Memory）是一种在Java中使用非堆外部内存的方式，它通常是通过java.nio包中的ByteBuffer或者相关的类来进行操作。直接内存并不是Java虚拟机管理的堆内存，而是由操作系统分配和管理的一块内存区域。

在Java中，通过直接内存可以利用操作系统提供的零拷贝特性，使得在进行I/O等操作时能够更加高效。一般来说，直接内存的使用场景包括对文件的映射、网络传输、以及需要零拷贝的大规模数据处理等。

- 直接内存不是虚拟机运行时数据区的一部分。

- 本机直接内存的分配不会受到Java堆大小的限制，受本机总内存的限制。

### 2.2 虚拟机对象探秘

探讨一下HotSpot虚拟机在Java堆中对象分配、布局和访问的全过程。

1. 对象的创建

- 遇到new指令，检查指令参数是否是常量池中的类符号引用，并检查符号所代表的类是否被加载、解析以及初始化。如果没有则加载类

- 分配内存空间。分配完成后，将内存空间初始化为0（实例对象默认初始化）

- 对对象进行设置：

    - 确定实例所属的类

    - 对象的哈希码

    - 对象的GC分代年龄等。

- 从jvm的角度，对象已经产生。但是从java应用程序的角度，仍需要执行**构造函数**

2. 对象的内存布局

对象在堆内存中的布局分为三个部分：

- 对象头

    - 第一部分，存储对象自身的运行时数据：哈希码，GC分代年龄，锁状态，线程持有的锁，偏向线程ID等。

    - 第二部分，类型指针，对象指向它的类型元数据的指针，java虚拟机通过这个指针来确定该对象是哪个类的实例。

- 实例数据：字段内容，父类继承字段和子类定义字段

- 对齐填充：对齐填充

3. 对象的访问定位

使用reference引用

### 2.3 OOM异常分析

1. java堆溢出

java堆溢出的条件：

- 对象数量不断增加

- GC roots到对象之间有可达路径

2. 虚拟机栈和本地方法栈溢出

虚拟机栈和本地方法栈有两种异常：

- 如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。

- 如果虚拟机的栈内存允许动态扩展，当扩展栈容量无法申请到足够的内存时， 将抛出OutOfMemoryError异常。HotSpot虚拟机不支持扩展，所以除非在创建线程申请内存时就因无法获得足够内存而出现OutOfMemoryError异常，否则在线程运行时是不会因为扩展而导致内存溢出的。

3. 方法区和运行时常量池溢出

4. 本机直接内存溢出


## 第三章

### 3.1 判断对象存活的算法

判断对象是否存活的算法有哪些？

- 引用计数法

    - 缺点：无法分析相互引用

- 可达性分析算法

    - 通过"GC Root"的根对象作为起点，根据引用关系向下搜索。从图论的角度来说，从GC root到这个对象不可达时，证明这个对象不可能再被引用。

    - GC root对象包括

        - 虚拟机栈栈帧中的参数、局部变量、临时变量

        - 方法区中类静态属性引用的变量

        - java虚拟机内部的引用

        - 被同步锁持有的对象
    
    这些GC Root对象构成GC root集。

方法区的垃圾回收主要回收哪些内容？

- 废弃的常量：例如运行时常量池中的定义的字符串常量（局部变量赋值使用字符串常量）

- 不再使用的类型

    如何判断类型不再被使用？

    - 该类所有的实例都被回收

    - 该类的加载器都被回收

    - 该类的Class对象没有在任何地方被引用

    如果满足上述条件，java虚拟机允许对类进行回收

### 3.2 垃圾收集算法

1. 垃圾收集器遵循"分代收集"理论进行设计：

- 弱分代假说：绝大多数对象都是瞬态的

- 强分代假说：熬过多次垃圾收集过程的对象就难以消灭

- 跨代引用假说：跨代引用相对于同代引用比较少

2. 根据上面的理论引出垃圾收集器的设计原则：收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区域之中存储。

3. 具体而言，在java虚拟机中，将java堆分为

- 新生代

- 老年代

4. 每个区域中存储对象存亡特性不同使用不同的算法：

- 标记-清除算法：先标记所有需要回收的对象，然后统一回收

    - 缺点：内存碎片

- 标记-复制算法：将内存划分为大小相等的两块，每次使用一块。当一块内存用完了，就将存活的对象复制到另外一块上，然后一次性清除本区域。

    - 缺点：将内存缩小一般，空间利用率低

- 标记-整理算法：先标记所有存活的对象，然后将存活对象移动到存储空间的一端，最后清理掉其他区域。

    - 缺点：移动大量对象和更新引用非常消耗性能，同时移动对象时必须全程暂停应用程序（stop the world）。
    

5. GC有哪些分类？

- 部分收集（partial gc）：指目标不是完整收集整个java堆的垃圾收集

    - 新生代收集（Minor GC）：目标新生代的垃圾收集

    - 老年代收集（Major GC）：目标老年代的垃圾收集

    - 混合收集（Mixed GC）：目标新生代和部分老年代的收集

- 整堆收集（full GC）：收集整个java堆和方法区的垃圾收集

### 3.3 应用

1. java中的引用，引用强度依次减弱：

- 强引用

    - Object obj = new Object()这种引用关系

    - 强引用关系在，垃圾收集器就不会回收

- 软引用

    - 用来描述还有用，但是非必须得对象。

    - 在系统将要发生内存溢出前，会对这些对象列进回收范围，进行二次回收，如果仍没有足够的内存，则抛出OOM异常

    - 如何理解上面的二次回收？

        - 第一次回收：当系统内存即将耗尽时，垃圾收集器会检查软引用关联的对象，并将这些对象标记为“即将回收”，此时软引用对象没有被回收

        - 第二次回收：在第一次回收后，系统仍没有足够的内存，垃圾收集器会检查标记为"可回收状态"的对象。

- 弱引用

    - 用来描述非必须对象，强度比软引用更弱

    - 弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。弱引用关联的对象在垃圾收集时会被立即回收，而不会像软引用那样经历两次回收的过程

- 虚引用

    - 最弱的一种引用关系

### 3.4 内存分配和回收

1. 对象的内存分配位置在哪里？

对象的内存分配都在堆上，在经典分代设计中，新生对象通常会分配在新生代中，少数情况下（较大对象）可能直接分配在老年代。

2. 内存分配的原则有哪些？

- 对象在新生代Eden区中分配，当Eden区没有足够的内存时，虚拟机将发起monitor GC

- 大对象，需要大量连续存储空间的java对象，例如大数组和大字符串。

    - 程序中应该避免大对象和大对象的复制，会导致提前触发GC，已经内存复制开销。

    - 大对象应该在老年代，避免在Eden区、Survior区、老年区之间复制数据

- 长期存活的对象将进入老年代

    对象通常在Eden区里诞生，如果经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，该对象会被移动到Survivor空间中，并且将其对象年龄设为1岁。对象在Survivor区中每熬过一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15），就会被晋升到老年代中。

- full GC

    在发生Minor GC之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那这一次Minor GC可以确保是安全的。否则可能执行full GC。

3. 什么时候会触发GC？

- 当Eden区没有足够的内存进行分配时，虚拟机将发起一次Minor GC

- 当老年代空间不足，将触发Full GC

- 当永久代空间不足，会触发full GC

- System.gc调用，请求垃圾回收，具体行为由虚拟机决定

### 3.5 选择合适的GC

选择适合GC的参考标准：

- 应用程序关注点是什么？

    - 数据分析、科学计算类的任务，目标尽快算出结果，需要关注吞吐量

    - 如果是SLA应用（例如阿里云），那停顿时间直接影响服务质量，严重的甚至会导致事务超时， 主要关注延迟

    - 如果是嵌入式应用，那垃圾收集的内存占用则是不可忽视的

- 应用程序的基础设施（硬件）？

- JDK的版本号？

### 垃圾收集过程中的一些关键指标

1. 衡量垃圾收集器的三个指标

- 内存占用

- 吞吐量

- 延迟

其中延迟的重要性越来越凸显

1. 停顿时间

什么是垃圾收集的停顿时间？

在进行垃圾收集时，整个应用程序在进行垃圾收集期间无法继续执行的时间，应用程序的执行被暂停的时间。

有几种停顿时间？

- Minor GC 停顿时间

    Minor GC期间，通常会有一些短暂的暂停，暂停时间较短不会对应用程序的性能产生明显影响。

- Full GC 停顿时间

    full GC 停顿时间较长，会对整个应用程序的性能和用户体验产生明显的影响。


​    
### CMS收集器（concurrent Mark Sweep）

1. CMS收集器的优点有哪些？

CMS收集器的显著特点是以最短回收停顿时间为目标的收集器。

2. CMS收集器适用于哪些服务和使用场景？

互联网网站和基于浏览器的B/S系统服务器，关注服务响应速度，希望系统挺短时间尽可能短。

3. CMS收集器的运作过程是？

- 初始标记

    - 停顿线程
    
    - 标记GC root对象

- 并发标记

    - 无须停顿线程，可以和用户线程一起执行

    - 从GC Roots对象开始并发标记所有关联对象

- 重新标记

    - 停顿线程

    - 修正并发标记阶段，用户线程导致并发标记变动的对象

- 并发清除

    - 不需停顿线程

    - 清理掉标记为已死亡的对象

4. CMS收集器的缺点

- 并发阶段占用额外线程，挤占应用程序所需要的资源

- 存在浮动垃圾。并发标记阶段和并发清除阶段，用户线程并发执行，可能产生新的垃圾，这部分垃圾称为“浮动垃圾”。浮动垃圾存在，造成GC不充分

- CMS基于标记清除算法，存在内存碎片

### Garbage First收集器（G1收集器）






## 第四章 虚拟机性能监控

### 4.1 故障定位处理工具

- 基础工具

    - jps：查询本地虚拟机唯一Id

    - jstat: 本地或者远程虚拟机进程中的类加载、内存、垃圾收集、即时编译等运行时数据

    - jmap：生成堆转储快照dump文件

    - jstack：生成虚拟机当前时刻的线程快照

- 可视化工具

    - Java visual VM

    - JConsole

## 第五章 性能调优


## 第六章 类文件结构

1. java虚拟机和平台无关，语言无关，如何理解？

java虚拟机不与java语言绑定，只和Class文件（字节码文件）绑定。其他语言如果能翻译成字节码，也可以使用java虚拟机运行。

### 6.3 class文件的结构

1. class文件的来源有哪些？

类文件、接口文件、动态代理生成

2. class文件采用**类C语言结构体**格式来存储数据，有两种数据类型：

- 无符号数，u1,u2,u4分别表示1个字节，2个字节，4个字节

- 表是由多个无符号数和其他表构成的复合数据类型，表的命名习惯以“_info”结尾。

3. class类文件的结构

- 魔数

- 主版本

- 副版本

- 常量池

- 访问标志

- 类索引、父类索引、接口索引集合

- 字段表集合

- 方法表集合

- 属性表集合


4. 常量池

常量池中主要存放哪些内容？

- 字面量：例如文本字符串，final类型的常量

- 符号引用：

    - 被模块导出的包

    - 类和接口的全限定名

    - 字段的名称和描述符

    - 方法的名称和描述符

    - 方法句柄和类型

    - 动态调用点和动态常量

5. 访问标志

访问标志用于确定类或者接口层次的访问信息，例如接口还是类，是否为public类型，是否为abstract类型，是否为final

6. 类索引、父类索引、接口索引集合

类索引、父类索引、接口索引集合的作用是什么？

这三项数据用于确定该类型的继承关系：

- 类索引确定类的全限定名

- 父类索引确定父类的全限定名

- 接口索引确定实现了哪些接口

7. 字段表集合

字段表集合的作用是什么？

字段表（field_info）用于描述接口或者类中声明的变量。包括类变量和实例变量

8. 方法表集合

方法表集合用于存储访问标志、名称索引、描述符索引、属性表集合。

9. 属性表集合

class文件，字段表，方法表都可以携带自己的属性表集合。

### 6.4节 字节码指令

java虚拟机指令由操作码和操作数构成。操作码占一个字节


### 字节码和数据类型

在操作码助记符中都有特殊的字符来表明为哪种数据类型服务，例如iload，表示加载int类的数据到操作数栈。

### 加载和存储指令

load操作用于将**局部变量**加载到**操作数栈**中：iload, lload

store操作用于将数据从操作数栈存储到局部变量表：istore，lstore

将一个常量加载到操作数栈：bipush, sipush, ldc


## 第七章 类的加载机制

1. 一个类的生命周期有哪些阶段？

- 加载

- 连接

    - 验证

    - 准备

    - 解析

- 初始化

- 使用

- 卸载

2. 类什么时候开始初始化的？

    - 遇到new，getstatic，putstatic，invokestatic这四条字节码指令的时候。

        - 使用new关键字实例化对象的时候

        - 读取或者设置一个类型的静态字段

        - 调用静态方法

    - 使用reflect包对类型进行反射的时候

    - 初始化类时，初始化其父类

    - 虚拟机启动时，用户需要执行一个主类

3. 哪些情况不会造成类的初始化？

    - 通过子类引用父类的静态字段，只会触发父类的初始化而非子类。只有直接定义这个静态字段类才会被初始化

    - 创建一个对象数组，数组元素实现类不会被初始化。通过数组定义引用类，不会造成类的初始化

    - 引用定义常量的类（static string s= xxx），不会触发定义类的初始化。

### 类的加载过程

#### 加载

加载的步骤有哪些？

- 通过类的全限定名来获取定义类的二进制字节流

    没有指明从哪里获取，如何获取，常见的应用有
    
    - 从zip压缩包获取（jar, ear, war）

    - 从网络中获取（web applet）

    - 运行时计算机生成（动态代理）

    - 其他文件生成（jsp文件生成class文件）

- 将字节流锁代表的静态数据结构转为为方法区运行时数据结构

- 在内存中生成一个代表这个类的class对象。

不同数据类型的加载阶段？

- 对于非数组类型，通过类加载器完成

- 对于数组类型

    - 数组类由java虚拟机直接在内存中动态创造

    - 元素类型仍依靠类加载器完成

#### 验证

验证阶段主要确保class文件符合java虚拟机规范的全部约束要求。

- 文件格式验证：验证字节流是否符合class文件格式规范

    - 是否已魔数开头

    - 主次版本号是否在接受范围内

    - 常量池中的常量是否支持？

    - 指向常量的索引值是否指向正确（常量是否存在）？

- 元数据验证：对字节流描述的信息进行语义分析

    - 该类是否有父类？

    - 该类是否继承了不被允许的类？

    - 是不是抽象类

    - 类中字段，方法是否与父类产生矛盾

#### 字节码验证

#### 引用符号验证

### 准备阶段

    准备阶段是正式为类中定义的变量（即静态变量， 被static修饰的变量） 分配内存并设置类变量初
    始值的阶段，

### 解析阶段

### 初始化阶段

初始化阶段是类加载过程的最后一个步骤，执行类构造器<clinit>()方法。<clinit>() 方法是一个特殊的方法，由编译器自动生成，用于执行类的静态初始化代码块和静态变量的赋值操作。

在多线程环境中<clinit>()方法如何执行？

java虚拟机保证一个类的<clint>()方法在多线程环境中被正确加锁同步，如果多个线程同时初始化一个类，则只会有一个线程去执行这个类的<clinit>()方法，其他线程阻塞，且唤醒后不再进入<clinit>方法中

### 7.4 类加载器

1. 类和类加载器的关系如何？

- 类加载器加载类的class文件

- 类和类加载器共同确定在虚拟机中唯一性。即比较两个类是否相等，必须同时比较类和类加载器。

2. 什么是三层类加载器？

    - 启动类加载器（bootstrap class loader）

        - 启动类加载器复杂加载JAVA_HOME/lib目录下的类库，而且按照文件名识别。     

    - 扩展类加载器（extention class loader）

        - 扩展类加载器可以用来加载JAVA_HOME/lib/ext目录中中的所有类库

        - 允许用户将通用性的类库放在ext目录以扩展java SE的功能。

    - 应用程序类加载器（application class loader）

        - 负责加载用户类路径上的所有类库

    - 自定义类加载器

        - 用户自己实现，可以加载磁盘位置之外的class文件，或者通过class加载器实现类的隔离、重载功能。

3. 什么是双亲委派模型？

双亲委派模型要求除了顶层的启动类加载器外，其他加载器都有自己的父类加载器。父子关系不是通过继承实现，而是使用组合方式实现。

4. 双亲委派模型的工作过程是？

如果一个类加载器收到了类的加载请求，首先不会自己去加载类，而是委托给父类去完成，最终都应该委托给启动类加载器去加载。只有当父类无法加载时，子加载器才会去加载。

5. 双亲委派模型的好处？

java中的类随着类加载器一起具备了优先级的层次关系。典型例子就是Object类，确保rt.jar中的Object类是所有类的唯一父类。


## 虚拟机字节码执行引擎



## 第十二章 Java内存模型和线程

java内存模型跟CPU缓存模型类似，是基于CPU缓存模型建立的，java内存模型是标准化的，屏蔽掉了底层不同计算机的区别。

### 12.2 硬件的效率和一致性（物理机的并发处理方案）

1.   为了解决CPU和存储设备之间的读写速度差异，引入了高速缓存
2.   但是高速缓存会导致“缓存一致性”问题：在多核操作系统中，每个处理器都有自己的高速缓存，同时又共享同一内存，当多个处理器的运算任务都涉及同一块主存区域时，将可能导致各自的缓存数据不一致。
3.   intelCPU通过MESI协议解决“缓存一致性”问题

### 12.3 Java内存模型

java内存模型是一种规范，用于屏蔽各种硬件和操作系统的内存访问差异，以实现java程序在各种平台下都能达成一致的内存访问效果。

c/c++直接使用物理硬件和操作系统的内存模型，不同平台上的内存模型差异可能导致相同代码在不同平台上运行结果不同。
#### 12.3.1 主内存和工作内存

1.   java内存模型的主要目的：定义程序中各种变量的访问规则，即虚拟机把变量值存到内存和从内存中取出变量。此处的变量指实例字段、静态变量以及构成数组对象的元素。

2.   Java内存模型

     -   主内存：
         -   可以类比为物理硬件内存
         -   jmm规定所有的变量都存在主内存中
     -   工作内存：
         -   每条线程还有工作内存，可以和处理器高速缓存类比
         -   工作内存中保存了被该线程使用的变量的内存副本
         -   线程对变量的所有操作（读、写）都必须在工作内存中进行
         -   不同的线程之间无法直接访问对方内存中的变量，线程间变量的传递需要通过主内存进行。

3.   jmm和jvm内存区域的关系

     -   两者基本没有什么关系，如果勉强对应则：
         -   主内存 : java堆中对象实例数据部分
         -   工作内存：对应与虚拟机栈中的部分区域。
     -   和硬件的对应关系：
         -   主存：对应物理硬件的内存
         -   工作内存：虚拟机可能会让工作内存优先存储在寄存器和高速缓存中

4.   内存间的交互操作

     java内存模型中定义了8中操作完成变量从主存拷贝到工作内存，从工作内存同步回主存：

     -   lock：作用于主存变量，把变量标识为一个线程独占
     -   unlock: 作用于主存变量，释放锁定状态的变量
     -   read：作用于主存，将变量从主内存读取到工作内存中，以便load使用
     -   load：作用于工作内存，将read读到工作内存中的变量存入变量副本中
     -   use：作用于工作内存，将工作内存变量传递给执行引擎，当虚拟机遇到一个需要**使用变量的值**的字节码指令时，将会执行这个动作
     -   assign：作用于工作内存，把一个从执行引擎接收的值赋给工作内存的变量。当虚拟机遇到给一个给**变量赋值**的字节码指令时执行这个操作
     -   store：作用于工作内存，将工作内存中的变量传送到主内存中，以便后续的write使用
     -   write：作用于主内存，将store操作的变量的值存入主内存变量中

5.   内存操作必须满足的规则

     -   把变量从主内存拷贝到工作内存，顺序执行read和load操作（read和load之间必须顺序执行，但是不要求连续执行，即两个操作之间可以插入其他操作）

     -   把变量从工作内存写入主内存，顺序执行store和write操作（store和write之间必须顺序执行，但是不要求连续执行，即两个操作之间可以插入其他操作）

     -   不允许read和load，store和write操作单独出现

     -   不允许一个线程丢弃最近的assign操作，变量在工作内存中修改后必须把变化同步回主内存

     -   不允许没有发生过assign操作却把数据从工作内存同步回主内存

     -   新变量只能在主内存中诞生，不允许在工作内存中直接使用未初始化变量

     -   一个变量在同一个时刻只允许一条线程对其进行lock操作，lock操作可以被同一线程重复执行，只有执行相同次数的unlock操作，变量才会被解锁

     -   如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或者assign操作以初始化工作内存中的值

     -   如果一个变量没有被lock操作锁定，则不允许执行unlock操作

     -   对一个变量执行unlock操作前，必须将变量同步回主存中

​	通过上述规则同一判断哪些内存访问操作在并发下是安全的。

6.   对volatile变量的特殊规则

     volatile变量具备两种特性：

     -   保证此变量对所有的线程可见，当一个线程修改变量的值，新值对其他线程立即可见。
     -   禁止指令重排序优化（重排序优化指的是机器级的优化操作，对应汇编代码优化重排）普通变量仅保证在线程执行过程中**依赖赋值结果的地方**都能获取到正确的结果，但是实际执行顺序和代码中的顺序可能不一致。

7.   如何理解volatile变量不保证原子性？

     volatile保证可见性，一个线程修改volatile变量后，必须将变量立即写回主内存。其他线程读取volatile变量时，必须从主存读取，然后执行读写操作。因此volatile具有可见性。但是线程读取后，其他线程仍然可以修改volatile的值，而此时，就可能造成数据异常。举例说明：线程A读取volitle变量执行自增操作，线程B在线程A读取，修改volatile变量的值，并写入主存，线程A完成自增操作，并将volatile变量写会主存，此时发生脏写。

8.   volatile变量的使用场景

     -   单一线程修改变量的值

     -   变量不需要和其他状态变量共同参与不变约束

​	其他使用场景仍需要加锁。

9.   指令重排在并发编程中的问题：

     线程A执行如下命令：x=10;y=11;z=x+y

     线程B执行如下命令：if(y=11) print(x);

     对于线程A：变量z依赖x和y，因此x=10和y=11一定在z=x+y之前执行，但是x=10和y=11哪个先执行，并不知道。

     对于线程B：如果线程A执行顺序是x=10;y=11，则打印10；如果线程A执行顺序是y=11;x=10，则打印结果可能是10，也可能是0

10.   volatile变量如何实现可见性？

      修改volatile变量A的机器码中会使用lock前缀，lock前缀会在执行指令时锁住内存总线，防止其他处理器同时修改相同的内存地址，同时该前缀将本处理器中变量A的缓存写入内存，写入动作同时引起其他处理器无效化变量A的缓存。其他处理器使用变量A时，只能重新执行store和load操作。

11.   volatile如何事项禁止指令重排？

      -   什么是指令重排？

          指令重排是指处理器允许将指令不按照程序规定的顺序进行处理，但是必须能正确处理指令依赖情况，确保得到正确的结果。因此在一个处理器中，重排序过的代码逻辑上依然是有序的

      当对volatile变量进行修改时，java规范确保将对该变量的修改同步到内存，并确保在这个指令之前的所有操作都已经完成。

12.   jmm对volatile变量限定的使用规则：

      -   线程对volatile变量A的前一个动作是load时，才能对变量A执行use操作（使用前，必须执行read，load操作）； 线程对volatile变量的后一个动作是use时，才能对变量执行load操作（只有在使用时，才能执行read，load操作）；即读取volatile变量，执行操作顺序必须是：read, ..., load, use

      -   线程对volatile变量A执行的前一个动作是assgn的时候，才能对变量A执行store动作；只有后一个动作是store时，才能执行assign操作。即修改volatile变量，执行操作顺序只能是：assgin, store, ..., write

13.   jmm是围绕着在并发过程中如何处理原子性，可见性和有序性三个特性来建立的，jmm是如何实现三者的：

      -   原子性
          -   jmm保证对基本数据类型的读写访问（除long和double）都是原子性
          -   提供lock和unlock操作满足更大范围的原子性保证（sync关键字）

      -   可见性
          -   普通变量：在工作区修改变量后，写回主存（允许延迟写回）；线程使用变量，可以使用工作区中副本变量（不更新）
          -   volatile变量：volatile的特殊规则保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新
          -   sync关键字：对一个共享变量执行unlock操作之前，必须先把变量同步回主内存中（执行store、 write操作） ”这条规则获得的。如果对一个共享变量执行lock操作，那将会清空工作内存中此变量的值， 在执行引擎使用这个变量前， 需要重新执行load或assign操作以初始化变量的值
          -   final变量：被final修饰的字段在构造器中一旦被初始化完成，其他线程就能看到final字段的值。

      -   有序性：
          -   Java程序中天然的有序性可以总结为一句话：如果在本线程内观察，所有的操作都是有序的；
          -   如果在一个线程中观察另一个线程，所有的操作都是无序的。
          -   Java语言提供了volatile和synchronized两个关键字来保证线程之间操作的有序性

14.   happens-before原则

      happens-before原则用来判断有序性。操作A先行发生于操作B，则操作A产生的影响能够被操作B看到。

      -   程序次序性规则：同一线程内

          -   动作不存在数据依赖关系，可以重排
          -   动作存在依赖关系，happens-before

          -   内部锁规则：内部锁的释放happens-before后续锁的申请
              -   这里的后续指的是时间上的先后关系
              -   内部锁规则和程序次序性规则可以解决多线程之间的可见性问题

      -   volatile变量规则：对volatile变量的写操作happens-before后续的读操作

      -   线程启动规则：线程的start方法happens-before被启动线程中的任何一个动作

      -   线程终止规则：线程中的任何一个动作happens-before该线程的join方法

## 第十三章 线程安全

### 13.2 锁优化

1.  什么是线程安全？

    当多个线程访问一个对象时，如果不需要额外的同步，或者进行其他的协调操作，调用这个对象都可以获得正确的结果，这个对象就是线程安全的。

2.   多线程共享的数据可以分为如下几类：

     -   不可变对象：一经创建其状态就保持不变的对象。
         -   共享基本类型的数据：定义时使用final修饰
         -   共享对象：
             -   类本身用final修饰，防止创建子类改变定义行为
             -   所有字段都用final修饰
             -   对象在初始化过程中没有逸出
             -   如果字段引用了状态可变的对象，private修饰，返回值进行防御性复制。

3.   如何实现线程安全？

     -   同步互斥（阻塞同步）
         -   synchronized
             -   代码块结构同步语法（方法或者代码块）
             -   可重入
             -   无条件阻塞后面的线程，无法中断、超时退出和强制已获取锁的线程释放锁
             -   重量级锁：阻塞和唤醒线程需要用户态和内核态的切换
         -   reentrantlock
             -   等待可中断
             -   可实现公平锁
             -   锁可以绑定多个条件
             -   reentranlock在功能上是sync的超集，性能大致相当，但还是优先推荐使用sync
     -   非阻塞同步
         -   阻塞同步是一种悲观的并发策略，默认为不做同步，那就肯定会出问题。
         -   非阻塞同步是一种乐观的并发策略，基于冲突检测的乐观并发策略。这种并发策略不需要把线程阻塞挂起。
             -   非阻塞同步需要借助硬件级别的同步命令实现
             -   cas命令（内存位置，旧预期值，新预期值）
             -   cas操作的ABA问题
     -   无同步方案
         -   线程本地存储

     ### 13.3 锁优化

     -   自旋锁和自适应自旋
         -   自旋锁：挂起线程和恢复线程需要上下文切换，比较耗时。如果锁定状态时间很短，可以使用自旋锁（处理器忙循环），避免上下文的忙循环。自旋等待时间有一定的限制，如果超过指定次数人没有成功，就会使用传统的方式挂起线程
         -   自适应自旋锁：虚拟机自动判定自选等待的次数
     -   锁消除：锁消除是指虚拟机即时编译器在运行时，对一些代码要求同步，但是对被检测到不可能存在共享数据竞争的锁进行消除。
     -   锁粗化：但是如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体之中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗
     -   轻量级锁
     -   偏向锁







 





