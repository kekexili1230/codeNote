<!--
 * @Author: kekexili1230 457738564@qq.com
 * @Date: 2024-01-20 16:35:30
 * @LastEditors: kekexili1230 457738564@qq.com
 * @LastEditTime: 2024-01-25 11:29:22
 * @FilePath: /mynote/RabbitMQ.md
 * @Description: 这是默认设置,请设置`customMade`, 打开koroFileHeader查看配置 进行设置: https://github.com/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%AE
-->
# RabbitMQ 

## AMQP（advance message queueing protocol）高级消息队列协议

是一个网络协议，应用层协议的开发标准。基于此协议的客户端和中间件可传递消息，并不受客户端和中间件的限制。

## RabbitMQ的基本概念

- Broker：

- virtual host：类似于租户和命名空间的概念

- Connection

- Channel

- exchange

    - direct

    - topic

    - fanout

- Queue

- Binding

## RabbitMQ的工作模式

- 简单模式

- work queue

- 发布、订阅

- routing路由

- topics

## RabbitMQ 详解

### mandatory 参数

- true ：当交换机无法根据自己的类型和路由键找到一个符合条件的队列时，会将消息返回给生产者

    - 生产者如何获取这条消息？通过注册一个ReturnListener监听函数

- false ：消息直接丢弃

### immediate参数

- true：如果交换机将消息路由到队列时发现队列上并不存在任何消费者，这条消息不会入队列。当与路由键匹配的所有队列都没有消费者时，该消息会返回生产者

- false: 消息放入队列中，等待投递


### 备份交换机

- 备份交换机的功能：将未被路由的消息存储在RabbitMQ中

- 如何使用备份交换机？可以在声明交换机的时候指定一个备份交换机，也可以使用策略模式。如果主交换机没有成功路由消息，则会发送到备份交换机上。

- 备份交换机也可以绑定队列，如果消息匹配失败，则消息丢失。如果备份交换机和mandatory参数一起使用，则参数无效。

### 消息的TTL

#### TTL两种设置方式

- 队列设置TTL：队列中所有的消息TTL都一致。

    - 消息过期（删除）时间：一旦消息过期，则会从队列中删除

- 消息设置TTL：单独设置每一条消息的TTL

    - 消息过期（删除）时间：消息过期，在队列中不会立刻删除，在投递时删除消息

- 如果同时设置两种方式，则消息的TTL取两者之间的最小值。

#### TTL值，单位毫秒

- 如果不设置TTL，则表示此消息不会过期

- 如果TTL设置为0，则除非表示此时可以直接投递给消费者，否则消息会被立刻丢弃
 
### 死信队列

当消息变为死信之后，会被发送到另外一个交换机，这个交换机就是DLX(Dead Letter Exchange)，绑定DLX的队列称为死信队列。

消息变为死信一般是由于一下几种情况：

- 消息被拒绝

- 消息过期

- 队列到达最大程度

### 延迟队列

RabbitMQ中可以通过DLX和TTL模拟出延迟队列的的功能

### 优先级队列

- 设置队列的最大优先级（最好在10以内，优先级越多越需要消耗额外的CPU和内存资源）

- 设置消息的优先级，数值越大，优先级越高

- 当消息在队列中存在堆积时，消费者从队列中优先取到优先级高的消息

### RPC

客户端A调用服务器B的流程：

- 服务器B设置一个请求队列Q

- 客户端设置一个回调队列C，通过队列Q向服务器B发送请求，请求中设置参数回调队列为C

- 服务器处理请求，并将结果返回给回调队列C

- 客户端处理回调队列C中的消息

为了提升性能，一般为每一个客户端创建一个回调队列。客户端中可能存在多个RPC请求，处理区分消息是一个请求的响应？

答：通过correlationId，用来关联请求和RPC的响应。为每一个请求设置一个correlationId


### 持久化

- 交换机的持久化

    - 如果交换机没有持久化，重启RabbitMQ服务器后，交换机消失，无法将消息发送给交换机

- 队列的持久化

    - 如果队列没有持久化，重启RabbitMQ服务器后，队列会丢失，队列中的消息也会丢失（无论消息是否持久化）

- 消息的持久化

    - 如果消息没有持久化，无论队列是否持久化，消息都会丢失

#### 持久化和消息丢失的关系

即使配置了持久化策略，在消费过程中消息也会丢失（客户端重启）。


### 生产者确认

- 事务机制

    - channel.txSelect 开启事务

    - channel.txCommit

    - channel.txRollback

    - 事务机制非常损耗性能

- 发送方确认机制

    - 生产者将信道设置为confirm模式

    - 生产者发送消息，消息分配一个唯一ID（从1开始）

    - 生产者将消息发送到匹配队列

    - 消息写入磁盘后（如果队列和消息持久化后），RabbitMQ就会发送一个确认（ACK，包好消息ID）给生产者。

    - 生产者通过回调函数确认消息发送成功

- 发送方确认机制和事务的对比

事务在发送消息之后会使发送端阻塞，等待RabbitMQ的响应。但是发送方确认机制可以通过回调函数获取响应信息，发送消息后可以继续发送消息

### 消费者确认和拒绝

- autoAck = true，RabbitMQ会自动把发送出去的消息置为确认，然后从内存或者磁盘中删除

- autoAck = false, RabbitMQ会一直持有消息，直到消费者显式调用Basic.ACK

当autoACK = false时，队列中的消息分成两部分，一部分是等待投递给消费者，一部分是已投递给消费者，但是尚未收到确认信息。如果此时消费者断开连接，则RabbitMQ会安排这些消息重新进入队列。

### 消息分发

- 轮询

- 轮询+设置消费者的prefetchCount，如果消费者未消费消息数量等于prefetchCount，则不会再向消费者发送消息

### 消息的顺序性

哪些情况会打破消息的顺序性呢？

- 生产者角度

    - 使用事务，事务回滚，使用其他线程重新发送消息，则消息顺序不确定

    - 使用发送方确认机制，因某种原因需要重发信息，消息入队列顺序可能乱序

    - 生产者消息设置死信队列，消息设置不同的超时时间，则消息会乱序

- 消费者

    - 消息队列优先级，消息优先级

### 消息传输保障



## RabbitMQ 面试总结

### 消息中间件的作用

- 解耦：解耦是指系统中的组件之间减少相互依赖，使得一个组件的改变不会影响其他组件。

    - 在 RabbitMQ 中的应用： 发送者将消息发布到 Exchange 中，而不需要知道具体的接收者是谁。接收者则通过订阅队列，从队列中获取消息。这种解耦方式使得系统中的不同模块能够独立演化，降低了模块之间的耦合度。

- 异步：异步通信是指消息的发送者和接收者不需要同时存在或同时处理，消息的发送和接收是异步的过程。

    - 在 RabbitMQ 中的应用： 发送者发送消息到 Exchange，而接收者通过订阅队列异步地获取消息。这种异步通信模式在分布式系统中特别有用，可以提高系统的可伸缩性和响应性。

- 削峰填谷：削峰填谷是指通过消息队列来平滑处理系统中的请求峰值，避免短时间内大量请求导致系统崩溃或性能下降。

    - 在 RabbitMQ 中的应用： 将请求发送到消息队列，然后由消费者异步地处理这些请求。这样可以避免瞬时大量请求直接冲击系统，通过队列缓冲和控制消费者的速率，使得系统更容易应对高峰值流量。

### 生产者如何确保将消息发送到MQ中？

1. 通过事务机制

- channel.txSelect：将当前信道设置成事务模式

- channel.txCommit：提交事务。

    - 事务提交后，信道将从事务模式切换为非事务模式，这意味着之后的消息发布和确认等操作将不再在事务中。

    - 表示事务中的操作被成功执行，并且消息被发送到相应的交换机（Exchange）（而不是队列）

- channel.txRollback：事务回滚。注：txRollback 方法会取消当前信道上的事务，将信道恢复到没有选择事务的状态。

事务机制是在**AMQP层面**提出的解决问题，事务机制会对性能产生一定的影响。

2. 通过发送方确认机制

RabbitMQ提出发送方确认机制，工作流程如下：

- 生产者将信道设置为confirm模式

- 生产者发送消息

- 信道上发布的消息会被指派一个唯一ID

- 消息进入队列后，RabbitMQ发送一个确认信息给生产者。

    - 如果消息和队列是持久化的，则确认消息会在写入磁盘后发出

- RabbitMQ回传给生产者的确认消息中有两个参数

    - deliveryTag：确认消息的序号

    - multiple：如果为true，则表示deliveryTag之前的消息都确认；否则只表示deliveryTag消息确认

发送方确认机制（publisher confirm）的优势在于不一定需要**同步确认**：

- 批量confirm：每发送一批信息，调用waitForConfirm方法，等待服务器确认

- 异步confirm：提供回调函数，服务端确认一条或者多条信息后回调这个方法进行处理。

3. 事务机制和发送方确认机制的对比

- 目的：

    - 发送方确认机制： 主要目的是确保消息能够被 RabbitMQ 服务器成功接收，提供一种异步确认机制。

    - 事务机制： 主要目的是提供强一致性，保证一组操作（例如消息发布、交换机与队列的绑定等）要么全部成功，要么全部失败。

- 性能开销：

    - 发送方确认机制： 通常比事务机制具有更低的性能开销，因为它是异步的，允许继续执行其他操作。

    - 事务机制： 事务机制可能对性能有较大的开销，因为需要等待所有操作都完成，并在提交事务后才能继续执行其他操作。

- 使用场景：

    - 发送方确认机制： 适用于需要高吞吐量的场景，对一致性要求较为灵活的应用。

    - 事务机制： 适用于对强一致性要求较高的场景，需要确保一组操作的原子性。


### RabbitMQ如何确保将消息发送到消费者

