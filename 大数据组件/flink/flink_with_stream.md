# flink笔记

## flink检查点算法原理和步骤

### 1. Checkpoint Barrie

flink检查点算法会通过数据源算子将检查点分隔符（checkpoint barrier）注入到数据流中。

Q1: 什么时候注入？

当触发检查点时，生成检查点分隔符。

Q2：什么时候触发检查点？

根据用户配置的检查点间隔时间触发的。用户会在创建流处理环境时使用 `enableCheckpointing(interval)` 方法来启用检查点功能，并指定检查点的间隔时间。

Q3：如果存在多个数据源，检查点分割符如何插入？

每次触发检查点时，Flink 会向所有的数据流中插入具有相同检查点 ID 的检查点栅栏（Checkpoint Barrier）。这意味着无论数据流来自于哪个数据源，它们都会共享相同的检查点 ID，以确保整个作业的状态一致性和一致性快照。

Q4：算子是如何利用检查点分隔符进行工作的？

-   Checkpoint Barrier 通常被表示为一种特殊的流事件，其中包含有关检查点的元数据信息，如检查点 ID 和检查点类型等
-   Checkpoint Barrier 通常是一个特殊类型的流事件对象，可以在数据流中与其他普通的数据记录一起传播。
-   当任务处理到一个检查点栅栏时，它会暂停处理当前数据，等待所有任务都达到同一个检查点栅栏，然后再继续处理后续的数据记录。

### 2. 数据源任务是如何处理Checkpoint Barrie的？

-   数据源任务收到checkpoint barrier后，暂停发出记录，生成数据源任务本地状态检查点
-   然后将检查点分割符和检查点编号广播至所有数据流分区
-   将状态保存为检查点后，状态后端通知任务，任务随后给JobManager发送确认消息，同时数据源恢复正常工作。

### 3. BarrierID和检查点ID的关系？

-   检查点编号（Checkpoint ID）是用于标识每个检查点的唯一标识符。它是由 Flink 的检查点协调器（Checkpoint Coordinator）生成的，通常是一个递增的整数序列。

-   检查点栅栏的编号（Barrier ID）：检查点栅栏是在执行检查点时插入到数据流中的特殊标记。Barrier ID 是用于标识每个检查点栅栏的唯一标识符，与对应的检查点相关联。
-   通常情况下，Flink 在触发检查点时会生成一个新的检查点编号，并将此编号包含在生成的每个检查点栅栏中。

### 4. 任务是如何对齐检查点分割符的？

-   检查点分割符总是以广播的形式发送给相关的任务
-   当任务收到一个分区(A)的新检查点分割符时，会继续等待其他输入分区(B、C、D)也发来的检查点分隔符。
    -   对于收到分区A来的数据，缓冲
    -   对于收到分区B、C、D来的数据，继续处理，直到收到相同的检查点分隔符
    -   等待所有分区分割符到达的过程称为对齐
    -   最后收到所有分区A、B、C、D的分隔符后，该任务通过状态后端生成检查点。最后将检查点分割符广播给下游所有的任务。

### 5. 数据汇任务是如何处理检查点分割符的？

-   数据汇任务收到分割符
-   数据汇任务执行分割符对齐
-   将自身状态写入检查点，同时向JobManager确认已经收到分隔符
-   JobManager在收到所有应用任务返回的检查点确认消息后，就会将此检查点标记为完成。

## 有状态算子的扩容和缩容

### 1. 带有键值分区状态的算子的扩容和缩容

-   假设数据流A中元素结构是(f0, f1)，f0共有N个不同的值，根据字段f0进行分区，则共有N个分区，同时具有N个键值分区状态。
-   假设扩容前算子B的并行度为M1，则每一个子任务实例负责N/M1个键值分区数据，同时具有N/M1个键值分区状态。
-   假设扩容后算子B的并行度为M2，则每一个子任务实例负责N/M2个键值分区数据，同时具有N/M2个键值分区状态。



