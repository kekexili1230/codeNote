# redis黑马教程笔记

## 第一章 redis缓存

1. 缓存更新策略有哪些？

- 超时剔除：redisTTL机制，到期后自动删除缓存，下次查询时更新缓存。
- 主动更新：修改数据库的时候，更新缓存  

2. 常用的主动更新策略有哪些？
    - cache aside pattern : 缓存调用者，在更新数据库的同时更新缓存
    - read/write through pattern：缓存和数据库整合为一个服务，由该服务来维护一致性。调用者无须关心缓存一致性。
    - write behind caching pattern：调用者只操作缓存，由其他线程异步的将缓存数据持久化到数据库，确保最终一致。

3. 在cache aside pattern方案中注意事项

    - 如何更新缓存？

        - 对数据库和缓存做相同的操作
        - 如果数据库有更新操作，则直接删除缓存。待查询时，走miss缓存操作。延迟缓存

    - 如何确保更新缓存和数据库操作的原子性？

        - 单体系统，将缓存和数据库操作放在一个事务中
        - 分布式系统，利用TCC等分布式事务方案

    - 先操作数据库还是先操作缓存？

        先操作数据库，再删除缓存。（倾向于）

4. 什么是缓存穿透？

    缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，请求永远不会生效，都会打到数据库上。

5. 缓存穿透的解决方案有哪些？

    - 缓存空对象
        - 优点：实现简单
        - 缺点：额外的内存消耗（增加TTL）；可能造成短期的不一致
    - 布隆过滤
        - 优点：内存占用少，没有多余的key
        - 缺点：可能仍存在缓存穿透

6. 什么是缓存雪崩？

    同一时间内大量的key缓存同时时效或者redis宕机，造成大量的数据请求到达数据库。

7. 如何解决缓存雪崩？
    - 给不同的key的TTL增加随机值（key集中失效）
    - 利用redis集群提供服务的可用性（redis宕机）
    - 给缓存业务增加降级限流策略

8. 什么是缓存击穿？

    缓存击穿问题也叫热点key问题，**被高并发访问**并且**缓存重建业务较复杂**的key突然失效，无数的请求会瞬间给数据库带来巨大的冲击。

9. 如何解决缓存击穿？

    - 互斥锁：重建缓存数据时使用互斥锁，这样只有一个线程在重建缓存。重建完成后，其他线程可以直接使用缓存结果。
        - 缺点：阻塞等待，性能较差
    - 逻辑过期：
        - 给记录设置逻辑过期时间
        - 查询记录时发现数据过期，本线程加锁，启用新的线程重建缓存，新线程构建完成释放锁。所有的线程均不等待，使用过期数据进行返回。

    

## 第二章、优惠券

### 2. 1 全局ID生成器

1.  为什么不使用数据库表自增ID？
    - 自增id的规律太明显
    - 受单表数据量的限制，订单太大 
2. 全局ID的特点
    - 唯一性
    - 高可用
    - 高性能
    - 递增
    - 安全性（规律性不明显） 
3. 如何使用redis实现全局ID？
    - 使用redis的自增操作生成唯一ID。redis自增操作是原子性
    - 创建一个计数器，每次使用incr命令返回一个唯一的递增ID

### 2.2 分布式锁

1. 满足分布式系统或者集群模式下多进程可见并且互斥的锁。具有如下特点：

- 多进程可用
- 互斥
- 高可用
- 高性能
- 安全性 

2. 有哪些分布式锁的实现？

|        | mysql                     | redis                    | zookeeper                        |
| ------ | ------------------------- | ------------------------ | -------------------------------- |
| 互斥   | 利用mysql本身的互斥锁机制 | 利用setnx这样的互斥命令  | 利用节点的唯一性和有序性实现互斥 |
| 高可用 | 好                        | 好                       | 好                               |
| 高性能 | 一般                      | 好                       | 一般                             |
| 安全性 | 断开连接，自动释放锁      | 利用锁超时时间，到期释放 | 临时节点，断开连接自动释放       |

3. 在redis中如何实现分布式锁？

    - 获取锁
        - 互斥：setnx lock thread1
        - 增加过期时间：expire lock 10
    - 释放锁
        - 手动释放
        - 超时释放

4. 什么是redis超时释放问题？

    线程1申请锁，并设置锁的超时时间，线程1执行业务逻辑，锁超时自动释放，线程2开始执行获取锁，线程1执行完毕，开始执行删除锁操作。此时由于锁是线程2创建的，线程1执行删除操作，会误删线程2创建的锁。

5. 如何解决锁的超时释放问题？

    插入锁的时候，增加标识；删除锁的时候，判断锁的标识是否是一致。

    不能使用线程ID，不同jvm下线程ID可能一致。使用UUID标识。

6. 在解决锁的超时释放问题时，必确确保判断和释放锁是一个原子操作。否则在判断和释放动作之间锁可能会过期，然后造成误删操作。

7. 基于setnx实现的分布式锁的问题：
    - 不可重入
    - 不可重试
    - 超时释放
    - 主从一致性：主节点上加锁，还没有同步给从节点，主机宕机，从节点没有同步锁信息。

8. redission的使用

    





 

