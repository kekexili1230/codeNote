# redis笔记

## 第五章 持久化

### RDB

1. 什么是RDB持久化？

RDB持久化是把当前进程数据**生成快照**保存到硬盘。

2. 如何触发RDB？

- 手动触发

- 自动触发

3. 如何手动触发？

- save命令：阻塞Redis服务器，直到RDB过程完成。可能造成长时间阻塞，不建议使用

- bgsave命令：Redis进程执行fork操作创建子进程，RDB持久化过程由子进程负责，完成后自动结束。阻塞只发生在fork阶段，时间短。

4. 如何配置自动触发？

- save m n : m秒内的数据集存在n次修改时，自动触发bgsave

- 节点执行全量复制操作，主节点自动执行bgsave生成RDB文件并发送给从节点。

- 指定debug reload命令重新加载redis时，也会自动触发save操作

- 默认情况下执行shutdown命令，如果没有开启AOF持久化功能则自动执行bgsave

5. RDB的优缺点？

- RDB的优点：

    - RDB是一个紧凑压缩的二进制文件，代表Redis在某个时间节点上的数据快照。

    - 加载RDB恢复数据远远快于AOF

- RDB的缺点：

    - 无法做到实时持久化。每次运行bgsave需要执行fork操作

    - RDB使用特定二进制格式保存，Redis版本不同，RDB格式不同


### AOF（append only file）

1. 什么是AOF？

以独立日志的方式**记录每次写命令**，重启时再重新执行AOF文件中的命令达到恢复数据的目的。AOF的主要作用是解决了数据持久化的实时性。

2. AOF的工作流程是什么？

AOF的工作流程如下：

- 命令写入：所有的写入命令追加到aof_buf

- 文件同步：缓冲区根据对应的策略向硬盘做同步操作

- 文件重写：定期对AOF文件进行重写

- 重新加载：服务器重启，可以加载AOF文件

3. 为什么要文件重写？

随着命令不断写入AOF，文件会原来越大，因此AOF重写机制压缩文件体积。

4. 重写后文件变小，原因有哪些？

- 进程内已经超时的数据不再写入文件

- 使用进程内最终数据直接生成写入命令，新的AOF文件只保留最终数据的写入命令。

    - 例如，旧的AOF文件中set hello haha, set hello byebye。新的AOF文件中只保留最终的数据

- 多条写入命令可以合并为一个

5. 持久化功能影响redis性能

## 第六章 复制

### 复制功能的配置

参与复制的Redis实例划分为主节点和从节点。每一个从节点只能有一个主节点，一个主节点可以有多个从节点。

1. 配置复制的三种方式：

- 在配置文件中加入

- 在redis-server启动命令后加入

- 直接使用命令

2. 断开复制

- 断开复制并不会抛弃原有数据，只是无法再获取节点上的数据变化。

    - 断开与主节点复制关系

    - 从节点晋升为主节点

- 实现切主操作：当前从节点对主节点的复制切换到另外一个主节点

    - 断开与旧主节点复制关系

    - 与新主节点建立复制关系

    - 删除从节点当前所有数据

    - 对新主节点进行复制操作

### 拓扑

1. 一主一从结构

    - 当应用写命令并发量较高且需要持久化时，可以只在从节点开启AOF。保证数据安全性的同时也避免了持久化对主节点的性能干扰。

    当主节点关闭持久化功能时，主节点脱机要避免自动重启操作。因为主节点没有开启持久化功能，重启后数据集为空，如果从节点继续复制主节点导致从节点数据也被清空。

2. 一主多从结构（星型）

    - 优点

        - 利用多个从节点实现读写分离。将读命令发送到从节点来分担主节点压力

        - 比较耗时的读命令，可以在一台从节点上执行，防止慢查询对主节点造成阻塞从而影响线上服务的稳定性

    - 缺点

        - 对于写并发量较高的场景，多个从节点会导致主节点写命令的多次发送从而造成过度消耗带宽。

3. 树状主从结构

从节点不但可以复制主节点数据，同时可以作为其他从节点的主节点继续向下层复制。通过引入复制中间层，可以有效降低主节点负载和需要传送给从节点的数据量。

### 原理

1. 保存主节点信息

2. 启动定时任务，定时任务发现存在主节点后，会尝试和主节点建立网络连接。

3. 发送ping命令：

    - 监测主从之间的网络套接字是否可用

    - 监测主节点当前是否可接受处理命令

4. 权限验证

5. 同步数据集，主节点将持有的数据全部发送给从节点

    - 全量同步：初次复制场景，主节点把全部数据一次性发送给从节点。

    - 部分同步：用于处理主从复制中因网络闪断等原因造成的数据丢失场景，重新连上主节点，主节点会补发丢失数据。

6. 命令持续复制：持续把写命令发送给从节点。

7. psync命令如何完成主从数据同步？

- 主从节点各自复制偏移量

- 主节点复制积压缓冲区

- 主节点运行Id

8. 复制偏移量机制

参与复制的主从节点都会维护自身复制偏移量。

- 主节点

    - 主节点在处理完写入命令后，会把命令的字节长度做累加记录存放在master_repl_offset中

    - 从节点每秒钟上报自身的复制偏移量给主节点，保存在主节点中

- 从节点

    - 从节点在接收到主节点发送的命令后，也会累加记录自身的偏移量。

通过对比主从节点的复制偏移量，可以判断主从节点数据是否一致。


9. 复制积压缓冲区

复制积压缓冲区是主节点上一个固定长度的先进先出队列。主节点响应写命令时，不但会把命令发送给从节点，还会写入复制积压缓冲区。用户部分复制和复制命令丢失的数据补救。

10. 主节点运行ID机制

主节点运行ID：动态分配一个40位的十六进制字符串作为运行ID，作为唯一识别Redis节点。

当运行ID变化后从节点将做全量复制。

11. 全量复制的流程

- 从节点发送`psync -1`命令进行数据同步

- 主节点收到`psync -1`解析出当前为全量复制，回复+FULLRESYNC响应

- 从节点接收主节点的响应数据数据保存运行ID和偏移量offset

- 主节点执行bgsave保存RDB文件到本地

- 主节点发送RDB文件给从节点，从节点接收RDB文件

    - 数据传输时间超过repl-timeout，从节点放弃接受RDB文件并清理已经下载的临时文件，全量复制失败

- 主节点发送RDB文件期间，仍然响应读写命令，并将写命令数据保存在复制客户端缓冲区。发送RDB文件后，主节点再把缓冲区内的数据发送给从节点，保证主从之间数据一致性。

    - 如果创建和传输RDB的时间过长，可能hui造成客户端复制缓冲区溢出。

- 从节点接收主节点传送过来的全部数据后会清空自身旧数据。

- 从节点清空数据后开始加载RDB文件

- 从节点成功加载RDB后，如果当前节点开启了AOF持久化功能，会立刻做bgrewriteaof操作

12. 部分复制的流程

    - 什么时候开启部分复制？

        部分复制主要是redis针对全量复制的过高开销做出的优化。当从节点正在复制主节点时，如果出现网络闪断或者命令丢失等异常情况，从节点会向主节点要求补发丢失的命令数据。

    - 部分复制的流程是什么？
        - 主从节点之间出现网络中断，如果超时repl-timeout时间，主节点断开复制连接
        - 主从连接中断期间主节点依然响应命令，主节点将写命令写入复制积压缓冲区
        - 主从节点之间网络恢复后，从节点会再次连上主节点
        - 从节点使用psync命令将已保存的偏移量和主节点的运行ID发送给主节点，要求进行部分复制。
        - 主节点接到psync命令后首先核对参数runId是否正确。然后检查参数offset在自身复制积压缓冲区中是否存在
        - 主节点根据偏移量把复制积压缓冲区里的数据发送给从节点，保证主从复制进入状态。

13. 心跳机制

    主从节点彼此都有心跳检测机制：

    - 主节点每隔10秒对从节点发送ping命令，判断从节点的存活性和连接状态。
    - 从节点在主线程中每隔1s发送replconf ack {offset}命令，向主节点上报自身当前的复制偏移量。
        - 通过replconf命令判断从节点超时时间，如果超过repl-timeout则判断从节点下线并断开客户端连接。

14. 异步复制

    主节点负责读写数据，然后采用**异步方式**将写命令同步给从节点。

### 数据复制可能出现的问题

#### 读写分离

1. 读写分离可能遇到哪些问题？

- 复制数据延迟
- 读到过期数据
- 从节点故障

2. 什么是复制数据延迟？如何解决该问题？

​	由于主从异步复制特性存在数据延迟，延迟取决于网络带宽和命令阻塞情况。对于无法容忍大量延迟场景，可以编写外部监控程序监听主从节点的复制偏移量。实现方式如下：

- 监控程序定期检查主从节点偏移量
- 如果偏移量过高，触发报警并通知客户端从节点延迟过高
- 客户端接到具体的从节点高延迟通知后，修改读命令路由到其他从节点或者主节点。
- 当延迟恢复后，再次通知客户端，恢复从节点读命令请求

3. 为什么会读到过期数据？

    - 主节点删除超时数据的策略主要有两种：

        - 惰性删除

            主节点执行读命令时检查数据是否超时，如果超时执行del命令，同时将del命令异步发送给从节点。

        - 定时删除

            主节点定时任务采样一定数量的键，当被采样键过期时执行del命令，同时将del命令异步发送给从节点

4. 从节点故障问题

    需要再客户端维护可用从节点列表，当从节点故障时立刻切换到其他从节点或者主节点

## 第七章 阻塞



## 第九章 哨兵模式

### 9.1 基本概念

1. 主从复制模式中从节点的作用有哪些？
    - 作为主节点的备份，确保数据不丢失
    - 扩展主节点的读能力
2.  Redis哨兵节点的作用是什么？
    - 监控：定期监测数据节点、哨兵节点是否正常
    - 通知：将故障转移结果通知给应用方
    - 主节点故障转移：选择从节点升级为主节点，并维护新的主从关系
    - 提供配置：客户端连接的是哨兵节点集合，从中获取主节点信息。

3. 哨兵节点发现故障并实现故障转移的过程是什么？
    - 主节点故障，从节点和主节点失去连接，主从复制失败
    - 哨兵节点定期监控发现主节点出现故障
    - 多个哨兵节点对主节点故障达成一致，选举哨兵节点作为领导者负责处理故障转移
    - 领导者选择一个从节点，执行slaveof no none ，使其作为新的主节点
    - 领导者命令其他从节点从新的主节点复制数据
    - 领导者通知应用方新的主节点信息
    - 领导者继续监控旧的主节点，待恢复后，让它去复制新的主节点。

### 9.5 哨兵模式实现原理

1. 哨兵模式中的三个定时任务
    - 每一个哨兵节点会向主节点、从节点和其他哨兵节点发送ping命令，进行心跳监测。任务频率1秒
    - 每一个哨兵节点会向主节点__sentinel__: hello频道发送自身信息，以及对主节点的判断。任务频率2秒。
        - 发现新的Sentinel节点
        - 交换主节点的状态信息
    - 每一个哨兵节点会向主节点发送info命令获取最新的拓扑结构。
        - 向主节点执行info命令，获取从节点信息。
        - 立刻感知新的从节点加入。
        - 节点不可达时，可以实时更新节点拓扑信息。
2. 主管下线和客观下线
    - 哨兵节点定时ping其他节点，如果规定时间内没有返回，则判定该节点主观下线。
    - 当哨兵节点判定主节点主观下线时，咨询其他节点对主节点的判断，当超过\<quorum\>个数时，判定为客观下线。

3. 领导者选出的哨兵节点负责故障转移
    - 从节点列表中选择一个作为新的主节点
        - 过滤不健康（主观下线）的节点
        - 选择优先级高的节点
        - 选择复制偏移量最大的从节点（复制的最完整）
        - 选择runid最先的从节点
    - 哨兵节点对选举出的节点执行slave of no one命令，让其成为主节点。
    - 哨兵节点向其他节点发送命令，让它们成为新主节点的从节点
    - 将旧的主节点更新为从节点，保持监控，当其恢复后命令去复制新的主节点

## 第十章 集群

### 数据分布

1. 分布式数据库常用的分区规则有哪些？
    - 哈希分区：系统会将数据的关键属性通过哈希函数计算得到一个哈希值，根据哈希值将数据分配到不同的分区中
    - 顺序分区：顺序分区是根据数据的某个属性将数据进行排序，然后按照一定的规则将数据划分到不同的分区中。

2. 如何理解顺序分区？

    -   基本概念：

        -   有序性：顺序分区要求数据按某种顺序排列，例如按时间、数值大小或字母顺序。

        -   区间划分：数据集被分成若干个区间，每个区间包含一部分连续的数据点。

        -   分配规则：每个数据点被分配到相应的区间中，通常是根据其排序后的位置。

    -   应用场景：

        -   据库系统中，顺序分区可以帮助提高查询效率和数据管理的灵活性。例如，将时间序列数据按年份或月份进行分区。

    -   优点：

        -   分区方式直观，易于理解和实现
        -   对于顺序访问和范围查询效率较高

    -   缺点：

        -   在某些情况下，对大规模数据进行排序可能会带来额外的开销

3. 如何理解哈希分区？

    -   基本概念

        -   哈希分区根据数据的哈希值进行分区。通常使用一个或多个字段的哈希值来决定数据的分区。
        -   数据通过哈希函数被均匀地分配到不同的分区中

    -   使用场景

        -   数据没有明显的排序特征，或需要均匀分布数据的场景
        -   需要随机访问数据的应用，如分布式数据库中的记录分布

    -   优点：

        -   能够保证数据在各分区间的均匀分布，减少数据倾斜问题。

        -   分区的创建和维护简单，不需要根据数据特点调整分区边界。

    -   缺点：

        -   不适合顺序访问和范围查询，因为数据在分区间的分布是随机的
        -   哈希冲突

4. 顺序分区中“重新定义分区边界”问题

    -   当新数据到来时，如果这些数据落在现有分区之外，可能需要重新定义分区边界以容纳新的分区。例如如果数据按年份分区，新的一年到来时，需要为新一年的数据创建新的分区
    -   如果数据增长超过预期（该分区内的数据量过大），现有分区可能变得过大，导致单个分区的存储和处理压力过大，需要重新划分分区以均衡负载。

    **注：**重新划分分区，需要数据迁移。重新新增分区，对系统有什么影响，具体问题具体分析。

5.   满足既能进行范围扫描，又能拥有哈希分区均匀分布特点的需求，可以使用的解决方案有：

     -   混合分区策略。

         -   实现步骤：

             -   一级分区（顺序分区）：首先按照某一个字段（如日期）进行顺序分区

             -   二级分区（哈希分区）：在每一个顺序内，再按另一个字段（如用户ID）进行哈希分区

     -   分层存储策略：

         -   数据表设计：
             -   基础层：存储原始订单数据，采用哈希分区来保证数据的均匀分布
             -   索引层：采用顺序分区存储数据
         -   

6.   常见的哈希分区规则有几种？

- 节点取余分区：节点数目N取余。hash(key) % N计算出哈希值。常用于数据库的分库分表规则。

- 一致性哈希分区

    - 系统中每一个节点分配一个token，这些token构成哈希环。通过顺时针方式可以遍历这些节点哈希环

    - 数据读写，执行节点查找操作时，先根据key计算hash值，顺时针遍历哈希环，找到第一个大于等于该哈希值的token节点。哈希环中每个节点负责一定范围的数据。

    - 一致性哈希数据分布如图所示

        ![image-20240602214013618](C:\Users\yuanqingjie\AppData\Roaming\Typora\typora-user-images\image-20240602214013618.png)

    - 一致性哈希的优缺点：

        - 优点：加入和删除节点只影响哈希环中相邻的节点，对其他节点无影响。
        - 缺点：
            - 加减节点会造成哈希环中部分数据无法命中，需要手动处理或者忽略，因此经常用于缓存场景（无法命中，则从数据库中读取）。
            - 普通的哈希一致性分区在增减节点时需要增加一倍或减去一半节点才能保证数据和负载均衡。

    - 引入虚拟节点

        - 什么是虚拟节点？
            - 虚拟节点是物理节点在哈希环上的多个映射点。每个物理节点可以对应多个虚拟节点
        - 数据如何通过虚拟节点映射到物理节点？
            - 虚拟节点在哈希环上分布，数据根据哈希值分配到虚拟节点，然后映射到对应的物理节点。
        - 有何好处？
            - 通过引入虚拟节点，数据可以更加均匀地分布到所有的物理节点上。虚拟节点越多，数据分布越均匀，从而实现更好的负载均衡。

- 虚拟槽分区

    - 使用哈希函数将数据映射到许多槽（slot）中。
    - 每一个节点负责一定数量的槽。
        - 在虚拟槽分区中，是通过映射的方式，将节点和一定数量的槽映射起来。
        - 在一致性哈希环中，是通过顺时针查找的方式，将槽和节点映射起来
    - 解耦数据和节点之间的关系。
    - 优点：相比节点取余分区算法，具有一致性哈希环相似的优点。相比一致性哈希环，节点和槽采用映射的方式，更加灵活。

1. 集群功能限制
    - 只支持具有相同slot值的key执行批量操作
    - 只支持在同一个节点上执行多key事务操作
    - 只支持一个数据库
    - 复制结构只支持一层主从复制

### 10.2 节点通信

redis采用gossip协议不断通信交换信息。gossip协议包括：

- ping消息：ping消息封装了自身节点和部分其他节点的状态数据
- meet消息：通知接受者加入集群
- pong消息：pong消息封装了自身状态信息。当接收到ping，meet消息时，作为响应消息回复给发送方
- fail消息：节点判定集群内另外一个节点下线时，向集群内广播fail消息

## 第十一章 缓存设计

1. 什么是缓存穿透？

    缓存穿透是指查询一个根本不存在的数据，缓存层和存储层都不会命中。

2. 如何解决缓存穿透问题？

    - 缓存空对象：当存储层不命中后，依然将空对象保存在缓存中，后续从缓存中获取。
    - 布隆过滤器拦截

3. 缓存空对象有什么问题？如何解决？

    - 空值做缓存。存储中更多的键，更多的空间。
        - 解决方案：可以设置一个较短的过期时间。
    - 缓存层和存储层数据不一致。如果存储层增加数据，就会出现缓存层和存储层不一致的问题。
        - 解决方案：使用消息系统清除缓存层中的空对象。

4. 布隆过滤器是如何工作的？

    布隆过滤器的核心是一个位数组和一组哈希函数。位数组长度固定，所有位初始化为0。通过多个哈希函数对输入元素进行哈希，得到一系列的哈希值，然后将位数组中对应位置的位设置为1。当检查一个元素是否在集合中时，同样对这个元素进行哈希，并检查对应的位是否都为1，若其中有一位不为1，则可以确定该元素一定不在集合中；如果所有位都为1，则该元素可能在集合中。

5. 布隆过滤器如何防止缓存被击穿？

    先通过布隆过滤器快速判断该查询结果是否存在，如果不存在，则可以避免对数据库等存储介质进行昂贵的查询操作，从而防止缓存击穿。

6. 什么是缓存雪崩？

    如果缓存层由于某些原因不能提供服务，所有请求都到达存储层，存储层的调用量暴增，造成存储层级联宕机的情况。

    

  







 

