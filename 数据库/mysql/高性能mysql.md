# 高性能mysql笔记

## 第三章

1.   两种类型的性能剖析

     -   基于执行时间的分析
         -   什么任务的执行时间最长
     -   基于等待的分析
         -   任务在什么地方被阻塞的时间最长


## 第四章

### 4.1 数据类型

1.   字符串类型
     -   应该避免使用字符串类型作为标识符。使用随机字符串作为主键可能会引起这些问题：
         -   插入值会随机写到索引的不同位置，使得insert更慢
         -   select语句更慢，因为逻辑上相邻的行会分布在磁盘和内存不同的地方。
         -   随机值会使得缓存赖以工作的访问局部性原理失败

### 4.2 schema设计中的陷阱

1.   太多的列

     mysql存储引擎在工作时需要再服务器层和存储引擎层之间通过行缓冲格式拷贝数据，然后在服务器层将缓冲内容解码成各个列。如下图所示：

     ![image-20240519165150267](C:\Users\yuanqingjie\AppData\Roaming\Typora\typora-user-images\image-20240519165150267.png)

     -   为什么不建议使用`select * from table`？

         不建议使用 `SELECT *` 的主要原因在于它会导致从存储引擎复制和传输大量不必要的数据，从而增加I/O成本、内存使用和网络带宽浪费，最终影响查询性能和系统资源使用。

### 4.3 大表分页查询优化

1.   基本的分页查询

     ```sql
     SELECT * FROM example ORDER BY id LIMIT 100 OFFSET 10000;
     ```

     工作原理：

     -   据库引擎按照 `id` 列排序数据。
     -   然后引擎扫描前 10000 行，尽管它们不会放到行缓冲区中，但仍需要读取并确定这些行。
     -   最后，数据库引擎从第 10001 行开始，读取并返回接下来的100 行。

     综上所述，offset越大，需要扫描跳过的行就越多，性能就越差。

2.   基于索引的分页查询

     ```sql
     -- 获取第一页
     SELECT * FROM example ORDER BY id LIMIT 100;
     
     -- 获取下一页（假设上一页最后一行的 id 为 1000）
     SELECT * FROM example WHERE id > 1000 ORDER BY id LIMIT 100;
     ```

     工作原理：

     -   数据库引擎根据 `id` 对表进行排序，读取前 100 行。

     -   使用上一页最后一行的 `id` 值（假设为 1000）作为下一页查询的起始点。
     -   数据库引擎通过索引直接找到 `id > 1000` 的行，从该行开始读取接下来的 100 行。

## 第五章

### 5.1 索引基础

哈希索引基于哈希表实现，只有精确匹配索引所有列的查询才有效。







